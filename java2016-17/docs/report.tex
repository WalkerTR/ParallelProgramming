\documentclass{article}

\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{amsmath}



\hypersetup{
    colorlinks = true,
    linkcolor = blue,
    anchorcolor = blue
}

\graphicspath{{img/}}





\title{Parallelization of Sokoban in Java}

\author{Davide Dal Bianco \\ 2598719}

\begin{document}

\maketitle

\section{Introduction}

\section{Parallel algorithm}
The provided sequential program uses a recursive function to compute all possible solutions which number of moves is below a given threshold. The board is then solved by increasing the threshold until at least one solution is found. \\
Two possible families of parallel algorithms to solve sokoban are:
\begin{itemize}
    \item A \textit{Master Worker} algorithm, where a master node creates jobs that are solved by an arbitrary number of workers.
    \item A \textit{Trasposition-Driven Scheduling} algorithm, where each node computes one move and distribute the resulting states among all the nodes according to a hash function.
\end{itemize}
However, according to the requirements, a Master Worker algorithm must be used, hence we will focus on this one only. \\
A typical Master Worker algorithm work as follows:
\begin{itemize}
    \item The master start creating the jobs and store them into a queue.
    \item The workers ask the master for job to process (work stealing), then return back the result (when needed) and/or broadcast some other information.
    \item The final solution is found by a worker or by the master using the results provided by the workers.
\end{itemize}
In the sokoban, the master can start to find the solution like in the sequential version. However, every time a board reaches a maximum number of moves, the resolution of that particular board is interrupted and the board is added to the jobs queue. In this way the master can partition the global space of the solutions, in order to partition the total work among the workers. Since each partition has a different amount of work to compute, it is important that the number of jobs is much higher than the number of workers, in order to minimize the load imbalance. On the other hand, a greater number of jobs introduce a greater communication overhead. It follows that a trade off between load imbalance and communication overhead must be found. \\
In order to reflect the provided sequential algorithm, the master solve the sokoban by gradually increasing the bound. Therefore there are two options:
\begin{itemize}
    \item The current bound is less or equal MAXHOPS and in this case only the master solve the board.
    \item The current bound is greater then MAXHOPS and in this case the master computes only the first MAXHOPS moves and the boards and the workers complete the resolution.
\end{itemize}
On the other hand, the workers are accepting new jobs from the master and, when a job is solved, the result is returned to the master. Another possible solution could be storing the cumulative result in each worker and return it back when no more jobs are available. However, workers have to notify the master they are ready for accepting a new job and therefore the communication overhead is about the same. The first solution has been chosen for its simplicity (we can think the result is piggybacked with the notification).

\section{Implementation}
The parallel algorithm is implemented by means of two different classes which encapsulate the master and the worker behaviour. The program must work for each number of node (even one), therefore the master node must be also a worker node. Since we have two different classes that incapsulate the two roles, the master is executed in a different thread. \\
Ibis has a built in function that elects a single node from all the joined instances. This allows to pick up a random node that will work as master. Since the number of nodes is known before the execution, we can submit it to Ibis using the java argument \texttt{-Dibis.pool.size=\#}. In this way, Ibis allows to wait until all instances have joined the pool and allows to retrieve the pool size at runtime. \\
The main of the program works as follows:
\begin{itemize}
    \item Ibis elects the server.
    \item If the current node is the server, it reads the board from the file and execute the \texttt{Server} class in a new thread.
    \item The \texttt{Worker} class is executed in the main thread.
\end{itemize}
Though the Master and the Worker are executed in two different threads, the level of parallelism is nearly zero. In fact, during the first part of the resolution workers are idle and during the second part of the resolution the master is doing IO only. For speedup measurement we can therefore assume that Master and Worker do not run concurrently. \\
In the program three different channels are used:
\begin{itemize}
    \item \textbf{greets}, used as synchronization point and to send the receive ports used by workers to accept incoming jobs.
    \item \textbf{jobSubmit}, used by the master to send the jobs to the workers.
    \item \textbf{results}, used by the workers to send the result back to the master.
\end{itemize}
In order to avoid deadlock all receive ports are opened before send ports. On the other hand, send ports are closed before receive ports.


\subsection{Master}
At the beginning, the master wait for the greeting messages from all workers containing the port used to accept new jobs. Moreover, this works as synchronization point to ensure all workers are connected and ready. \\
After the startup phase, the master start solving the board by increasing the bound. Instead of using a recursive function, an iterative one has been used.


\subsection{Worker}

\section{Performance measurement}

\section{Improvements}

\end{document}