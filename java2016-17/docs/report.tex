\documentclass{article}

\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{amsmath}



\hypersetup{
    colorlinks = true,
    linkcolor = blue,
    anchorcolor = blue
}

\graphicspath{{img/}}





\title{Parallelization of Sokoban in Java}

\author{Davide Dal Bianco \\ 2598719}

\begin{document}

\maketitle

\section{Introduction}

\section{Parallel algorithm}
The provided sequential program uses a recursive function to compute all possible solutions which number of moves is below a given threshold. The board is then solved by increasing the threshold until at least one solution is found. \\
Two possible families of parallel algorithms to solve sokoban are:
\begin{itemize}
    \item A \textit{Master Worker} algorithm, where a master node creates jobs that are solved by an arbitrary number of workers.
    \item A \textit{Trasposition-Driven Scheduling} algorithm, where each node computes one move and distribute the resulting states among all the nodes according to a hash function.
\end{itemize}
However, according to the requirements, a Master Worker algorithm must be used, hence we will focus on this one only. \\
A typical Master Worker algorithm work as follows:
\begin{itemize}
    \item The master start creating the jobs and store them into a queue.
    \item The workers ask the master for job to process (work stealing), then return back the result (when needed) and/or broadcast some other information.
    \item The final solution is found by a worker or by the master using the results provided by the workers.
\end{itemize}
In the sokoban, the master can start to find the solution like in the sequential version. However, every time a board reaches a maximum number of moves, the resolution of that particular board is interrupted and the board is added to the jobs queue. In this way the master can partition the global space of the solutions, in order to partition the total work among the workers. Since each partition has a different amount of work to compute, it is important that the number of jobs is much higher than the number of workers, in order to minimize the load imbalance. On the other hand, a greater number of jobs introduce a greater communication overhead. It follows that a trade off between load imbalance and communication overhead must be found. \\
In order to reflect the provided sequential algorithm, the master solve the sokoban by gradually increasing the bound. Therefore there are two options:
\begin{itemize}
    \item The current bound is less or equal MAXHOPS and in this case only the master solve the board.
    \item The current bound is greater then MAXHOPS and in this case the master computes only the first MAXHOPS moves and the boards and the workers complete the resolution.
\end{itemize}
On the other hand, the workers are accepting new jobs from the master and, when a job is solved, the result is returned to the master. Another possible solution could be storing the cumulative result in each worker and return it back when no more jobs are available. However, workers have to notify the master they are ready for accepting a new job and therefore the communication overhead is about the same. The first solution has been chosen for its simplicity (we can think the result is piggybacked with the notification).

\section{Implementation}
The parallel algorithm is implemented by means of two different classes which encapsulate the master and the worker behaviour. The program must work for each number of node (even one), therefore the master node must be also a worker node. Since we have two different classes that incapsulate the two roles, the master is executed in a different thread. \\
The number of nodes is knows before the execution, hence we can submit it to Ibis using the java argument \texttt{-Dibis.pool.size=#}. In this way, Ibis allows to wait until all instances have joined the pool and allows to retrieve the pool size at runtime. We can also use Ibis to elect the server and the main of the program works as follows:
\begin{itemize}
    \item Ibis elects the server.
    \item If the current node is the server, it reads the board from the file and execute the \texttt{Server} class in a new thread.
    \item The \texttt{Worker} class is executed.
\end{itemize}

\subsection{Master}

\subsection{Worker}

\section{Performance measurement}

\section{Improvements}

\end{document}